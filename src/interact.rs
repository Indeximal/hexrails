//! This module is concerned with mouse interaction with objects in the world.
//!
//! This currently consists of two events being emitted:
//! - [`NodeClickEvent`] whenever an [`InteractionNode`] was clicked on.
//! - [`TileClickEvent`] whenever the background world was clicked.
//!
//! A tile event will only be emitted if no node was interacted with and
//! a node event will be emitted for every node which is active, but only
//! one will have the `primary` flag set.
//!
//! Everything is updated in `PreUpdate`, if you need to run anything dependent,
//! use `.after()` with [`InteractSet`].
//!
//! [`TrainClickEvent`] are generated in addition to the other two events.
//!

use bevy::ecs::system::SystemParam;
use bevy::prelude::*;
use bevy_inspector_egui::bevy_egui::EguiContext;

use crate::camera::WorldViewCam;
use crate::input::Action;
use crate::tilemap::{Direction, Joint, Tile};
use crate::trains::{BumperNode, Trail, TrainIndex};

pub struct InteractPlugin;
impl Plugin for InteractPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<TileClickEvent>()
            .add_event::<NodeClickEvent>()
            .add_event::<TrainClickEvent>()
            // Ordering the event to be after the input, but still in PreUpdate,
            // so in Update the events are available
            .add_systems(
                PreUpdate,
                (
                    update_interaction_status.before(emit_events),
                    emit_events.after(leafwing_input_manager::plugin::InputManagerSystem::Update),
                    emit_train_events.after(emit_events),
                )
                    .in_set(InteractSet),
            )
            .add_systems(Update, draw_interaction_nodes);
    }
}

/// The systems in PreUpdate emitting the events.
#[derive(SystemSet, Debug, Clone, PartialEq, Eq, Hash)]
pub struct InteractSet;

/// A circle collider in the world that can be interacted with.
///
/// Also needs an [`InteractionStatus`] component.
#[derive(Component)]
pub struct InteractionNode {
    pub radius: f32,
}

/// The status of an [`InteractionNode`], i.e. whether the cursor is
/// away from this node, above it (Hit) or the nearest hit.
///
/// Updated by [`update_interaction_status`].
///
/// Potentially werid behavior just after a click, since then the cursor position
/// is sometimes None.
#[derive(Component, PartialEq, Eq, Default)]
pub enum InteractionStatus {
    #[default]
    None,
    Hit,
    NearestHit,
}

/// This event will be generated by [`InteractPlugin`] whenever a tile was clicked on.
#[derive(Event, Debug)]
pub struct TileClickEvent {
    pub coord: Tile,
    pub side: Option<Direction>,
    pub button: MouseButton,
}

/// This event will be generated by [`InteractPlugin`] whenever an [`InteractionNode`] was clicked on.
#[derive(Event, Debug)]
pub struct NodeClickEvent {
    /// The entity with the [`InteractionNode`] component.
    pub node: Entity,
    /// The action that was taken to trigger this event.
    pub action: Action,
    /// Was this the nearest node hitting the click?
    ///
    /// If this is false, this was just another node that was also below the cursor,
    /// but deemed secondary.
    pub primary: bool,
}

/// Generated whenever a bumper of a train was clicked.
///
/// This is generated in addition to the [`NodeClickEvent`] and only for the primary one.
#[derive(Event)]
pub struct TrainClickEvent {
    /// The id of the [`TrainBundle`] entity.
    pub train: Entity,

    /// The "fence-post" index of where the train was clicked.
    ///
    /// I.e. between wagons with index `bumper_index` and `bumper_index+1`.
    pub bumper_index: u16,

    /// The bumper entity that was clicked.
    pub bumper_entity: Entity,
}

/// System for generating the interaction events..
///
/// Currently uses `bevy_input` directly, see
/// <https://github.com/Leafwing-Studios/leafwing-input-manager/issues/527>
fn emit_events(
    mouse_input: Res<ButtonInput<MouseButton>>,
    nodes: Query<(Entity, &InteractionStatus)>,
    mut tile_event_writer: EventWriter<TileClickEvent>,
    mut node_event_writer: EventWriter<NodeClickEvent>,
    mut world_interaction: WorldInteractionQuery,
) {
    // Only proceed if the build button has been pressed
    if !mouse_input.just_pressed(MouseButton::Left) {
        return;
    }

    let mut any_node_hit = false;
    for (id, status) in &nodes {
        let is_primary = match status {
            InteractionStatus::Hit => false,
            InteractionStatus::NearestHit => true,
            _ => continue,
        };
        any_node_hit = true;

        node_event_writer.send(NodeClickEvent {
            node: id,
            // FIXME: should depend on input of course...
            action: Action::Build,
            primary: is_primary,
        });
    }

    if any_node_hit {
        // No tile event should be emitted if there was a node clicked.
        return;
    }

    let Some(world_pos) = world_interaction.get_cursor_world_pos() else {
        // Ignore out of bounds etc.
        return;
    };

    let event = match Joint::from_world_pos(world_pos) {
        Ok(Joint { tile, side }) => TileClickEvent {
            coord: tile,
            side: Some(side),
            button: MouseButton::Left,
        },
        Err(tile) => TileClickEvent {
            coord: tile,
            side: None,
            button: MouseButton::Left,
        },
    };
    tile_event_writer.send(event);
}

fn update_interaction_status(
    mut nodes: Query<(
        Entity,
        &GlobalTransform,
        &InteractionNode,
        &mut InteractionStatus,
    )>,
    mut world_interaction: WorldInteractionQuery,
) {
    let cursor_pos = world_interaction.get_cursor_world_pos();

    let mut nearest = None;
    for (id, position, node, mut status) in nodes.iter_mut() {
        let position = position.translation();

        // signed square distance, weird metric, but negative if inside, positive if outside.
        let signed_distance =
            cursor_pos.map(|p| p.distance_squared(position.xy()) - node.radius.powi(2));

        let Some(signed_distance) = signed_distance else {
            status.set_if_neq(InteractionStatus::None);
            continue;
        };

        if signed_distance < 0.0 {
            // inside.
            // Can still double trigger if was and is NearestHit.
            status.set_if_neq(InteractionStatus::Hit);

            match nearest {
                None => nearest = Some((id, signed_distance)),
                Some((_, least_dist)) if signed_distance < least_dist => {
                    nearest = Some((id, signed_distance))
                }
                _ => (),
            };
        } else {
            // outside
            status.set_if_neq(InteractionStatus::None);
        }
    }

    if let Some((id, _)) = nearest {
        let (_, _, _, mut status) = nodes
            .get_mut(id)
            .expect("id was assigned by the same query");

        *status = InteractionStatus::NearestHit;
    }
}

fn emit_train_events(
    mut trigger: EventReader<NodeClickEvent>,
    mut writer: EventWriter<TrainClickEvent>,
    bumpers: Query<(&Parent, &BumperNode)>,
    vehicles: Query<(&TrainIndex, &Parent)>,
    trains: Query<(Entity, &Trail, &Children)>,
) {
    for ev in trigger.read() {
        if !ev.primary {
            // only trigger from one side, action should be symmetric.
            continue;
        }
        let Ok((bump_parent, bump_dir)) = bumpers.get(ev.node) else {
            continue;
        };
        let Ok((index, vehicle_parent)) = vehicles.get(bump_parent.get()) else {
            error!("BumperNode should always be attached to a vehicle!");
            continue;
        };
        let Ok((train, _trail, _train_children)) = trains.get(vehicle_parent.get()) else {
            error!("Vehicles should always be attached to a train!");
            continue;
        };

        let bumper_index = match bump_dir {
            BumperNode::Front => index.position,
            BumperNode::Back => index.position + 1,
        };

        // Debug some invariants:
        #[cfg(test)]
        {
            if !_trail.check_invariant() {
                error!("Trail invariant broken on {train:?}!");
            }
            if index.position >= _trail.length {
                error!(
                    "Found vehicle {:?} with index greater than train {train:?}'s length!",
                    bump_parent.get()
                );
            }
            if _train_children.len() != _trail.length as usize {
                error!("Train {train:?}'s length in trail does not match number of children!");
            }
        }

        trace!("Train {train:?} clicked at {bumper_index}");
        writer.send(TrainClickEvent {
            train,
            bumper_index,
            bumper_entity: ev.node,
        });
    }
}

fn draw_interaction_nodes(
    nodes: Query<(&GlobalTransform, &InteractionNode, &InteractionStatus)>,
    mut gizmos: Gizmos,
) {
    for (position, node, status) in &nodes {
        let position = position.translation();

        let color = match status {
            InteractionStatus::None => Color::GRAY,
            InteractionStatus::Hit => Color::YELLOW,
            InteractionStatus::NearestHit => Color::ORANGE_RED,
        };

        gizmos.circle(
            position.xy().extend(0.0),
            Direction3d::Z,
            node.radius,
            color,
        );
    }
}

/// A query for the purpose of calling [`Self::get_cursor_world_pos`].
///
/// TODO:
/// There might be an advantage to converting this to an leafwing dual axis action.
/// With that the cursor position might get persisted more often...
#[derive(SystemParam)]
struct WorldInteractionQuery<'w, 's> {
    /// Windows to get the cursor position
    windows: Query<'w, 's, &'static Window>,
    /// Camera to convert it to a world position. Must be exactly 1 such camera.
    cam: Query<'w, 's, (&'static GlobalTransform, &'static Camera), With<WorldViewCam>>,
    /// Query to ignore interactions over egui windows
    egui_contexts: Query<'w, 's, &'static mut EguiContext>,
    /// Query to ignore interactions over bevy_ui buttons
    other_buttons: Query<'w, 's, &'static Interaction>,
}

impl<'w, 's> WorldInteractionQuery<'w, 's> {
    /// Returns `None` if the cursor is outside the viewport, the viewport cannot be computed,
    /// the viewport cannot be mapped to the world or the cursor is above a UI.
    fn get_cursor_world_pos(&mut self) -> Option<Vec2> {
        // Skip if the mouse is above a inspector window or other gui
        // Can't be a run condition due to mutable context.
        // <https://github.com/mvlabat/bevy_egui/issues/47>
        // For some very stupid reason does `wants_pointer_input` return false for 1 frame,
        // exactly when the mouse button is pressed.
        let on_egui = self
            .egui_contexts
            .iter_mut()
            .any(|mut ctx| ctx.get_mut().is_pointer_over_area());
        if on_egui {
            return None;
        }

        let on_bevy_ui = self
            .other_buttons
            .iter()
            .any(|&interact| interact == Interaction::Pressed || interact == Interaction::Hovered);
        if on_bevy_ui {
            return None;
        }

        let (pos, cam) = self.cam.single();
        let Ok(window) = self.windows.get_single() else {
            warn!("Cannot deal with multiple windows!");
            return None;
        };

        cam.viewport_to_world_2d(pos, window.cursor_position()?)
    }
}
