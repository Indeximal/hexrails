use bevy::ecs::system::SystemParam;
use bevy::prelude::*;
use bevy_inspector_egui::bevy_egui::EguiContext;

use crate::camera::WorldViewCam;
use crate::input::{Action, GameInput};
use crate::tilemap::{Direction, Joint, Tile};

pub struct InteractPlugin;
impl Plugin for InteractPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<TileClickEvent>()
            .add_systems(PreUpdate, mouse_button_events)
            .add_systems(Update, draw_interaction_nodes);
    }
}

/// A circle in the world that can be interacted with
#[derive(Component)]
pub struct InteractionNode {
    pub radius: f32,
}

/// This event will be generated by [`InteractPlugin`] whenever a tile was clicked on.
#[derive(Event)]
pub struct TileClickEvent {
    pub coord: Tile,
    pub side: Option<Direction>,
    pub button: MouseButton,
}

/// System for generating [`TileClickEvent`].
fn mouse_button_events(
    game_input: Res<GameInput>,
    mut click_event: EventWriter<TileClickEvent>,
    mut world_interaction: WorldInteractionQuery,
) {
    // Only proceed if the build button has been pressed
    if !game_input.just_pressed(&Action::Build) {
        return;
    }

    let Some(world_pos) = world_interaction.get_cursor_world_pos() else {
        // Ignore out of bounds etc.
        return;
    };

    let event = match Joint::from_world_pos(world_pos) {
        Ok(Joint { tile, side }) => TileClickEvent {
            coord: tile,
            side: Some(side),
            button: MouseButton::Left,
        },
        Err(tile) => TileClickEvent {
            coord: tile,
            side: None,
            button: MouseButton::Left,
        },
    };
    click_event.send(event);
}

fn draw_interaction_nodes(
    nodes: Query<(&GlobalTransform, &InteractionNode)>,
    mut world_interaction: WorldInteractionQuery,
    mut gizmos: Gizmos,
) {
    let Some(world_pos) = world_interaction.get_cursor_world_pos() else {
        // Ignore out of bounds etc.
        return;
    };

    for (position, node) in &nodes {
        let position = position.translation();

        let color = if position.xy().distance_squared(world_pos) < node.radius.powi(2) {
            // In range
            Color::ORANGE_RED
        } else {
            // Out of range
            Color::RED
        };

        gizmos.circle(position, Direction3d::Z, node.radius, color);
    }
}

#[derive(SystemParam)]
struct WorldInteractionQuery<'w, 's> {
    /// Windows to get the cursor position
    windows: Query<'w, 's, &'static Window>,
    /// Camera to convert it to a world position. Must be exactly 1 such camera.
    cam: Query<'w, 's, (&'static GlobalTransform, &'static Camera), With<WorldViewCam>>,
    /// Query to ignore interactions over egui windows
    egui_contexts: Query<'w, 's, &'static mut EguiContext>,
    /// Query to ignore interactions over bevy_ui buttons
    other_buttons: Query<'w, 's, &'static Interaction>,
}

impl<'w, 's> WorldInteractionQuery<'w, 's> {
    /// Returns `None` if the cursor is outside the viewport, the viewport cannot be computed,
    /// or the viewport cannot be mapped to the world.
    fn get_cursor_world_pos(&mut self) -> Option<Vec2> {
        // Skip if the mouse is above a inspector window or other gui
        // Can't be a run condition due to mutable context.
        // <https://github.com/mvlabat/bevy_egui/issues/47>
        // For some very stupid reason does `wants_pointer_input` return false for 1 frame,
        // exactly when the mouse button is pressed.
        let on_egui = self
            .egui_contexts
            .iter_mut()
            .any(|mut ctx| ctx.get_mut().is_pointer_over_area());
        if on_egui {
            return None;
        }

        let on_bevy_ui = self
            .other_buttons
            .iter()
            .any(|&interact| interact == Interaction::Pressed || interact == Interaction::Hovered);
        if on_bevy_ui {
            return None;
        }

        let (pos, cam) = self.cam.single();
        let Ok(window) = self.windows.get_single() else {
            warn!("Cannot deal with multiple windows!");
            return None;
        };

        cam.viewport_to_world_2d(pos, window.cursor_position()?)
    }
}
