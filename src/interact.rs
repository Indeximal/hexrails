use bevy::ecs::system::SystemParam;
use bevy::prelude::*;
use bevy_inspector_egui::bevy_egui::EguiContext;

use crate::camera::WorldViewCam;
use crate::input::{Action, GameInput};
use crate::tilemap::{Direction, Joint, Tile};

pub struct InteractPlugin;
impl Plugin for InteractPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<TileClickEvent>()
            // Ordering the event to be after the input, but still in PreUpdate,
            // so in Update the events are available
            .add_systems(
                PreUpdate,
                mouse_button_events
                    .after(leafwing_input_manager::plugin::InputManagerSystem::Update),
            )
            .add_systems(PreUpdate, update_interaction_status)
            .add_systems(Update, draw_interaction_nodes)
            .add_systems(Update, event_logger);
    }
}

/// A circle collider in the world that can be interacted with
#[derive(Component)]
pub struct InteractionNode {
    pub radius: f32,
}

/// The status of an [`InteractionNode`], i.e. whether the cursor is
/// away from this node, above it (Hit) or the nearest hit.
///
/// Updated by [`update_interaction_status`].
///
/// Potentially werid behavior just after a click, since then the cursor position
/// is sometimes None.
#[derive(Component, PartialEq, Eq, Default)]
pub enum InteractionStatus {
    #[default]
    None,
    Hit,
    NearestHit,
}

/// This event will be generated by [`InteractPlugin`] whenever a tile was clicked on.
#[derive(Event)]
pub struct TileClickEvent {
    pub coord: Tile,
    pub side: Option<Direction>,
    pub button: MouseButton,
}

/// System for generating [`TileClickEvent`].
fn mouse_button_events(
    game_input: Res<GameInput>,
    mut click_event: EventWriter<TileClickEvent>,
    mut world_interaction: WorldInteractionQuery,
) {
    // Only proceed if the build button has been pressed
    if !game_input.just_pressed(&Action::Build) {
        return;
    }

    let Some(world_pos) = world_interaction.get_cursor_world_pos() else {
        // Ignore out of bounds etc.
        return;
    };

    let event = match Joint::from_world_pos(world_pos) {
        Ok(Joint { tile, side }) => TileClickEvent {
            coord: tile,
            side: Some(side),
            button: MouseButton::Left,
        },
        Err(tile) => TileClickEvent {
            coord: tile,
            side: None,
            button: MouseButton::Left,
        },
    };
    click_event.send(event);
}

fn event_logger(mut evs: EventReader<TileClickEvent>) {
    for ev in evs.read() {
        trace!("TileClickEvent received: {:?}", ev.coord);
    }
}

fn update_interaction_status(
    mut nodes: Query<(
        Entity,
        &GlobalTransform,
        &InteractionNode,
        &mut InteractionStatus,
    )>,
    mut world_interaction: WorldInteractionQuery,
) {
    let cursor_pos = world_interaction.get_cursor_world_pos();

    let mut nearest = None;
    for (id, position, node, mut status) in nodes.iter_mut() {
        let position = position.translation();

        // signed square distance, weird metric, but negative if inside, positive if outside.
        let signed_distance =
            cursor_pos.map(|p| p.distance_squared(position.xy()) - node.radius.powi(2));

        let Some(signed_distance) = signed_distance else {
            status.set_if_neq(InteractionStatus::None);
            continue;
        };

        if signed_distance < 0.0 {
            // inside.
            // Can still double trigger if was and is NearestHit.
            status.set_if_neq(InteractionStatus::Hit);

            match nearest {
                None => nearest = Some((id, signed_distance)),
                Some((_, least_dist)) if signed_distance < least_dist => {
                    nearest = Some((id, signed_distance))
                }
                _ => (),
            };
        } else {
            // outside
            status.set_if_neq(InteractionStatus::None);
        }
    }

    if let Some((id, _)) = nearest {
        let (_, _, _, mut status) = nodes
            .get_mut(id)
            .expect("id was assigned by the same query");

        *status = InteractionStatus::NearestHit;
    }
}

fn draw_interaction_nodes(
    nodes: Query<(&GlobalTransform, &InteractionNode, &InteractionStatus)>,
    mut gizmos: Gizmos,
) {
    for (position, node, status) in &nodes {
        let position = position.translation();

        let color = match status {
            InteractionStatus::None => Color::GRAY,
            InteractionStatus::Hit => Color::YELLOW,
            InteractionStatus::NearestHit => Color::ORANGE_RED,
        };

        gizmos.circle(
            position.xy().extend(0.0),
            Direction3d::Z,
            node.radius,
            color,
        );
    }
}

#[derive(SystemParam)]
struct WorldInteractionQuery<'w, 's> {
    /// Windows to get the cursor position
    windows: Query<'w, 's, &'static Window>,
    /// Camera to convert it to a world position. Must be exactly 1 such camera.
    cam: Query<'w, 's, (&'static GlobalTransform, &'static Camera), With<WorldViewCam>>,
    /// Query to ignore interactions over egui windows
    egui_contexts: Query<'w, 's, &'static mut EguiContext>,
    /// Query to ignore interactions over bevy_ui buttons
    other_buttons: Query<'w, 's, &'static Interaction>,
}

impl<'w, 's> WorldInteractionQuery<'w, 's> {
    /// Returns `None` if the cursor is outside the viewport, the viewport cannot be computed,
    /// the viewport cannot be mapped to the world or the cursor is above a UI.
    fn get_cursor_world_pos(&mut self) -> Option<Vec2> {
        // Skip if the mouse is above a inspector window or other gui
        // Can't be a run condition due to mutable context.
        // <https://github.com/mvlabat/bevy_egui/issues/47>
        // For some very stupid reason does `wants_pointer_input` return false for 1 frame,
        // exactly when the mouse button is pressed.
        let on_egui = self
            .egui_contexts
            .iter_mut()
            .any(|mut ctx| ctx.get_mut().is_pointer_over_area());
        if on_egui {
            return None;
        }

        let on_bevy_ui = self
            .other_buttons
            .iter()
            .any(|&interact| interact == Interaction::Pressed || interact == Interaction::Hovered);
        if on_bevy_ui {
            return None;
        }

        let (pos, cam) = self.cam.single();
        let Ok(window) = self.windows.get_single() else {
            warn!("Cannot deal with multiple windows!");
            return None;
        };

        cam.viewport_to_world_2d(pos, window.cursor_position()?)
    }
}
